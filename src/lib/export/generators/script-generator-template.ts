/**
 * Script Generator Template Method Pattern
 * Defines skeleton algorithm for script generation
 *
 * Benefits:
 * - Code reuse through template method
 * - Consistent structure across generators
 * - Easy to add new generator types
 * - Encapsulates common algorithm
 * - Hook methods for customization
 *
 * Template Algorithm:
 * 1. beforeGenerate (hook)
 * 2. generateHeader (abstract)
 * 3. processEntry for each entry (abstract)
 * 4. generateFooter (hook)
 * 5. joinLines
 * 6. afterGenerate (hook)
 */

import type { LogEntry, LogHeaders } from '@/types';
import { escapeShellArg } from '../escapers/shell-escaper';
import { escapePowerShellArg } from '../escapers/powershell-escaper';

/**
 * Abstract base class defining the template method
 */
export abstract class ScriptGenerator {
  /**
   * Template method - defines the skeleton algorithm
   * This is final and cannot be overridden by subclasses
   */
  generate(entries: LogEntry[]): string {
    // Hook: before generation
    this.beforeGenerate(entries);

    const lines: string[] = [];

    // Step 1: Generate header
    lines.push(...this.generateHeader());

    // Step 2: Process each entry
    for (let i = 0; i < entries.length; i++) {
      const entry = entries[i];
      if (entry) {
        lines.push(...this.processEntry(entry, i));
      }
    }

    // Step 3: Generate footer (optional)
    lines.push(...this.generateFooter());

    // Step 4: Join lines
    const result = this.joinLines(lines);

    // Hook: after generation
    this.afterGenerate(result);

    return result;
  }

  /**
   * Abstract method: Generate script header
   * Must be implemented by subclasses
   */
  protected abstract generateHeader(): string[];

  /**
   * Abstract method: Process a single entry
   * Must be implemented by subclasses
   */
  protected abstract processEntry(entry: LogEntry, index: number): string[];

  /**
   * Hook method: Generate footer (optional)
   * Can be overridden by subclasses
   */
  protected generateFooter(): string[] {
    return [];
  }

  /**
   * Hook method: Called before generation
   * Can be overridden by subclasses
   */
  protected beforeGenerate(_entries: LogEntry[]): void {
    // Default: do nothing
  }

  /**
   * Hook method: Called after generation
   * Can be overridden by subclasses
   */
  protected afterGenerate(_result: string): void {
    // Default: do nothing
  }

  /**
   * Common method: Join lines into final output
   * Can be overridden if different joining logic is needed
   */
  protected joinLines(lines: string[]): string {
    return lines.join('\n') + '\n';
  }
}

/**
 * Options for Bash Curl Generator
 */
export interface BashCurlOptions {
  includeHeaders?: boolean;
}

/**
 * Bash Curl Script Generator
 */
export class BashCurlScriptGenerator extends ScriptGenerator {
  private options: BashCurlOptions;

  constructor(options: BashCurlOptions = { includeHeaders: false }) {
    super();
    this.options = options;
  }

  protected generateHeader(): string[] {
    return ['#!/bin/bash', '# Generated by WebreqSniffer', ''];
  }

  protected processEntry(entry: LogEntry): string[] {
    const url = escapeShellArg(entry.url);
    let command = 'curl -L';

    if (this.options.includeHeaders && entry.headers) {
      const headers = this.formatHeadersForCurl(entry.headers);
      command += headers;
    }

    command += ` ${url}`;
    return [command];
  }

  private formatHeadersForCurl(headers: LogHeaders): string {
    const parts: string[] = [];
    for (const [key, value] of Object.entries(headers)) {
      const headerValue = escapeShellArg(`${key}: ${value}`);
      parts.push(` -H ${headerValue}`);
    }
    return parts.join('');
  }
}

/**
 * Bash yt-dlp Script Generator
 */
export class BashYtDlpScriptGenerator extends ScriptGenerator {
  protected generateHeader(): string[] {
    return ['#!/bin/bash', '# Generated by WebreqSniffer', ''];
  }

  protected processEntry(entry: LogEntry): string[] {
    const url = escapeShellArg(entry.url);
    let command = 'yt-dlp';

    // Add headers
    if (entry.headers) {
      command += this.formatHeadersForYtDlp(entry.headers);

      // Add referer flag if present (yt-dlp specific)
      if (entry.headers.Referer) {
        const referer = escapeShellArg(entry.headers.Referer);
        command += ` --referer ${referer}`;
      }
    }

    command += ` ${url}`;
    return [command];
  }

  private formatHeadersForYtDlp(headers: LogHeaders): string {
    const parts: string[] = [];
    for (const [key, value] of Object.entries(headers)) {
      const headerValue = escapeShellArg(`${key}: ${value}`);
      parts.push(` --add-header ${headerValue}`);
    }
    return parts.join('');
  }
}

/**
 * PowerShell Script Generator
 */
export class PowerShellScriptGenerator extends ScriptGenerator {
  protected generateHeader(): string[] {
    return ['# Generated by WebreqSniffer', '$ProgressPreference = "SilentlyContinue"', ''];
  }

  protected processEntry(entry: LogEntry, index: number): string[] {
    const lines: string[] = [];
    const url = `"${escapePowerShellArg(entry.url)}"`;

    lines.push(`# Request ${index + 1}`);

    if (entry.headers && Object.keys(entry.headers).length > 0) {
      lines.push('$headers = @{');
      for (const [key, value] of Object.entries(entry.headers)) {
        const escapedValue = escapePowerShellArg(value);
        lines.push(`    "${key}" = "${escapedValue}"`);
      }
      lines.push('}');
      lines.push(`Invoke-WebRequest -Uri ${url} -Headers $headers`);
    } else {
      lines.push(`Invoke-WebRequest -Uri ${url}`);
    }

    lines.push('');

    return lines;
  }
}
