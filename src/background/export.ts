/**
 * Export Module
 * Handles log export to various script formats
 */

import type { LogEntry, LogHeaders, ExportFormat, ExportSettings } from '@/types';
import { ExportError } from '@/lib/errors';
import { EXPORT } from '@/lib/constants';
import { renderTemplate } from '@/lib/template';
import { getBuiltInTemplate } from '@/lib/builtinTemplates';
import { sanitizeFilename } from '@/lib/filename';
import {
  safeEvaluate,
  isJavaScriptExpression,
  type TemplateContext,
} from '@/lib/template-evaluator';

/**
 * Escape string for Bash shell (single quotes)
 */
export function escapeShellArg(str: string): string {
  // In single quotes, only single quote needs escaping
  // We escape it by ending the quote, adding escaped quote, and starting quote again
  return `'${str.replace(/'/g, "'\\''")}'`;
}

/**
 * Escape string for PowerShell
 */
export function escapePowerShellArg(str: string): string {
  // PowerShell uses backtick for escaping
  return str
    .replace(/`/g, '``')
    .replace(/\$/g, '`$')
    .replace(/"/g, '`"')
    .replace(/\n/g, '`n')
    .replace(/\r/g, '`r');
}

/**
 * Helper: Create bash script header
 */
function createBashHeader(): string[] {
  return ['#!/bin/bash', '# Generated by WebreqSniffer', ''];
}

/**
 * Helper: Format headers for curl/yt-dlp
 */
function formatHeaders(headers: LogHeaders | undefined, format: 'curl' | 'yt-dlp'): string {
  if (!headers || Object.keys(headers).length === 0) return '';

  const parts: string[] = [];
  for (const [key, value] of Object.entries(headers)) {
    const headerValue = escapeShellArg(`${key}: ${value}`);
    if (format === 'curl') {
      parts.push(` -H ${headerValue}`);
    } else {
      parts.push(` --add-header ${headerValue}`);
    }
  }
  return parts.join('');
}

/**
 * Generate plain URL list
 */
export function generateUrlList(entries: LogEntry[]): string {
  return entries.map((entry) => entry.url).join('\n') + '\n';
}

/**
 * Generate Bash curl script (no headers)
 */
export function generateBashCurl(entries: LogEntry[]): string {
  const lines = createBashHeader();

  for (const entry of entries) {
    const url = escapeShellArg(entry.url);
    lines.push(`curl -L ${url}`);
  }

  return lines.join('\n') + '\n';
}

/**
 * Generate Bash curl script with headers
 */
export function generateBashCurlHeaders(entries: LogEntry[]): string {
  const lines = createBashHeader();

  for (const entry of entries) {
    const url = escapeShellArg(entry.url);
    const headers = formatHeaders(entry.headers, 'curl');
    lines.push(`curl -L${headers} ${url}`);
  }

  return lines.join('\n') + '\n';
}

/**
 * Generate Bash yt-dlp script
 */
export function generateBashYtDlp(entries: LogEntry[]): string {
  const lines = createBashHeader();

  for (const entry of entries) {
    const url = escapeShellArg(entry.url);
    let command = 'yt-dlp';

    command += formatHeaders(entry.headers, 'yt-dlp');

    // Add referer if present (yt-dlp specific)
    if (entry.headers?.Referer) {
      const referer = escapeShellArg(entry.headers.Referer);
      command += ` --referer ${referer}`;
    }

    command += ` ${url}`;
    lines.push(command);
  }

  return lines.join('\n') + '\n';
}

/**
 * Generate PowerShell script
 */
export function generatePowerShell(entries: LogEntry[]): string {
  const lines: string[] = [
    '# Generated by WebreqSniffer',
    '$ProgressPreference = "SilentlyContinue"',
    '',
  ];

  for (let i = 0; i < entries.length; i++) {
    const entry = entries[i];
    if (!entry) continue;

    const url = `"${escapePowerShellArg(entry.url)}"`;

    lines.push(`# Request ${i + 1}`);

    if (entry.headers && Object.keys(entry.headers).length > 0) {
      lines.push('$headers = @{');
      for (const [key, value] of Object.entries(entry.headers)) {
        const escapedValue = escapePowerShellArg(value);
        lines.push(`    "${key}" = "${escapedValue}"`);
      }
      lines.push('}');
      lines.push(`Invoke-WebRequest -Uri ${url} -Headers $headers`);
    } else {
      lines.push(`Invoke-WebRequest -Uri ${url}`);
    }

    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Generate filename from template
 * Supports both simple variables ({date}) and JavaScript expressions ({videoTitle?.toLowerCase()})
 */
export function generateFilename(
  template: string,
  format: ExportFormat,
  entries: LogEntry[]
): string {
  const now = new Date();
  const date = now.toISOString().slice(0, 10); // YYYY-MM-DD
  const time = now.toISOString().slice(11, 19).replace(/:/g, '-'); // HH-mm-ss

  // Extract domain and metadata from first entry
  let domain: string = EXPORT.DEFAULT_DOMAIN;
  const firstEntry = entries.length > 0 ? entries[0] : null;
  const metadata = firstEntry?.pageMetadata;

  if (firstEntry) {
    try {
      const url = new URL(firstEntry.url);
      domain = url.hostname.replace(/[^a-zA-Z0-9.-]/g, '_');
    } catch {
      // Invalid URL, use default
    }
  }

  // Determine extension
  const ext = EXPORT.EXTENSIONS[format];

  // Extract program date from manifest
  let programDate: string | undefined;
  if (metadata?.manifestMetadata?.programDateTime) {
    try {
      const dateObj = new Date(metadata.manifestMetadata.programDateTime);
      programDate = dateObj.toISOString().slice(0, 10);
    } catch {
      programDate = undefined;
    }
  }

  // Create template context for expression evaluation
  const context: TemplateContext = {
    // Page metadata
    pageTitle: metadata?.pageTitle,
    ogTitle: metadata?.ogTitle,
    videoTitle: metadata?.videoTitle,
    metaTitle: metadata?.metaTitle,
    metaDescription: metadata?.metaDescription,

    // Manifest metadata
    manifestTitle: metadata?.manifestMetadata?.title,
    manifestType: metadata?.manifestMetadata?.type,
    segmentPattern: metadata?.manifestMetadata?.segmentPattern,
    programDate,

    // System variables
    date,
    time,
    timestamp: Date.now(),
    domain,
    ext,
  };

  // Process template with JavaScript expression support
  const jsExpressionPattern = /\{([^}]+)\}/g;

  const filename = template.replace(jsExpressionPattern, (match, expression) => {
    const trimmedExpr = expression.trim();

    // Check if it's a JavaScript expression
    if (isJavaScriptExpression(trimmedExpr)) {
      // Evaluate as JavaScript expression
      return safeEvaluate(trimmedExpr, context, match);
    }

    // Simple variable reference - use context value
    const value = context[trimmedExpr as keyof TemplateContext];
    return String(value ?? '');
  });

  // Sanitize filename
  return sanitizeFilename(filename);
}

/**
 * Generate export content based on format
 * All formats now use the template system
 */
export function generateExportContent(entries: LogEntry[], format: ExportFormat): string {
  // All formats now use templates
  const template = getBuiltInTemplate(format);
  if (!template) {
    throw new ExportError(`Template not found for format: ${format}`, { format });
  }
  return renderTemplate(template.template, entries);
}

/**
 * Export logs to file
 */
export async function exportLogs(
  entries: LogEntry[],
  format: ExportFormat,
  exportSettings: ExportSettings
): Promise<string> {
  if (entries.length === 0) {
    throw new ExportError('No entries to export', { entryCount: 0 });
  }

  // Generate content
  const content = generateExportContent(entries, format);

  // Apply newline settings
  const finalContent = exportSettings.newline === 'CRLF' ? content.replace(/\n/g, '\r\n') : content;

  // Generate filename
  const filename = generateFilename(exportSettings.filenameTemplate, format, entries);

  // Create blob
  const blob = new Blob([finalContent], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);

  // Download file
  const downloadId = await chrome.downloads.download({
    url,
    filename,
    saveAs: true,
  });

  // Clean up blob URL after download
  chrome.downloads.onChanged.addListener(function cleanup(delta) {
    if (delta.id === downloadId && delta.state?.current === 'complete') {
      URL.revokeObjectURL(url);
      chrome.downloads.onChanged.removeListener(cleanup);
    }
  });

  return filename;
}
