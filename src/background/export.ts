/**
 * Export Module
 * Handles log export to various script formats
 */

import type { LogEntry, LogHeaders, ExportFormat, ExportSettings } from '@/types';

/**
 * Escape string for Bash shell (single quotes)
 */
export function escapeShellArg(str: string): string {
  // In single quotes, only single quote needs escaping
  // We escape it by ending the quote, adding escaped quote, and starting quote again
  return `'${str.replace(/'/g, "'\\''")}'`;
}

/**
 * Escape string for PowerShell
 */
export function escapePowerShellArg(str: string): string {
  // PowerShell uses backtick for escaping
  return str
    .replace(/`/g, '``')
    .replace(/\$/g, '`$')
    .replace(/"/g, '`"')
    .replace(/\n/g, '`n')
    .replace(/\r/g, '`r');
}

/**
 * Helper: Create bash script header
 */
function createBashHeader(): string[] {
  return ['#!/bin/bash', '# Generated by WebreqSniffer', ''];
}

/**
 * Helper: Format headers for curl/yt-dlp
 */
function formatHeaders(headers: LogHeaders | undefined, format: 'curl' | 'yt-dlp'): string {
  if (!headers || Object.keys(headers).length === 0) return '';

  const parts: string[] = [];
  for (const [key, value] of Object.entries(headers)) {
    const headerValue = escapeShellArg(`${key}: ${value}`);
    if (format === 'curl') {
      parts.push(` -H ${headerValue}`);
    } else {
      parts.push(` --add-header ${headerValue}`);
    }
  }
  return parts.join('');
}

/**
 * Generate plain URL list
 */
export function generateUrlList(entries: LogEntry[]): string {
  return entries.map((entry) => entry.url).join('\n') + '\n';
}

/**
 * Generate Bash curl script (no headers)
 */
export function generateBashCurl(entries: LogEntry[]): string {
  const lines = createBashHeader();

  for (const entry of entries) {
    const url = escapeShellArg(entry.url);
    lines.push(`curl -L ${url}`);
  }

  return lines.join('\n') + '\n';
}

/**
 * Generate Bash curl script with headers
 */
export function generateBashCurlHeaders(entries: LogEntry[]): string {
  const lines = createBashHeader();

  for (const entry of entries) {
    const url = escapeShellArg(entry.url);
    const headers = formatHeaders(entry.headers, 'curl');
    lines.push(`curl -L${headers} ${url}`);
  }

  return lines.join('\n') + '\n';
}

/**
 * Generate Bash yt-dlp script
 */
export function generateBashYtDlp(entries: LogEntry[]): string {
  const lines = createBashHeader();

  for (const entry of entries) {
    const url = escapeShellArg(entry.url);
    let command = 'yt-dlp';

    command += formatHeaders(entry.headers, 'yt-dlp');

    // Add referer if present (yt-dlp specific)
    if (entry.headers?.Referer) {
      const referer = escapeShellArg(entry.headers.Referer);
      command += ` --referer ${referer}`;
    }

    command += ` ${url}`;
    lines.push(command);
  }

  return lines.join('\n') + '\n';
}

/**
 * Generate PowerShell script
 */
export function generatePowerShell(entries: LogEntry[]): string {
  const lines: string[] = [
    '# Generated by WebreqSniffer',
    '$ProgressPreference = "SilentlyContinue"',
    '',
  ];

  for (let i = 0; i < entries.length; i++) {
    const entry = entries[i];
    if (!entry) continue;

    const url = `"${escapePowerShellArg(entry.url)}"`;

    lines.push(`# Request ${i + 1}`);

    if (entry.headers && Object.keys(entry.headers).length > 0) {
      lines.push('$headers = @{');
      for (const [key, value] of Object.entries(entry.headers)) {
        const escapedValue = escapePowerShellArg(value);
        lines.push(`    "${key}" = "${escapedValue}"`);
      }
      lines.push('}');
      lines.push(`Invoke-WebRequest -Uri ${url} -Headers $headers`);
    } else {
      lines.push(`Invoke-WebRequest -Uri ${url}`);
    }

    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Generate filename from template
 */
export function generateFilename(
  template: string,
  format: ExportFormat,
  entries: LogEntry[]
): string {
  const now = new Date();
  const date = now.toISOString().slice(0, 10); // YYYY-MM-DD

  // Extract domain from first entry's URL
  let domain = 'logs';
  if (entries.length > 0 && entries[0]) {
    try {
      const url = new URL(entries[0].url);
      domain = url.hostname.replace(/[^a-zA-Z0-9.-]/g, '_');
    } catch {
      // Invalid URL, use default
    }
  }

  // Determine extension
  const extensions: Record<ExportFormat, string> = {
    'url-list': 'txt',
    'bash-curl': 'sh',
    'bash-curl-headers': 'sh',
    'bash-yt-dlp': 'sh',
    powershell: 'ps1',
  };
  const ext = extensions[format];

  // Replace placeholders
  return template
    .replace(/{date}/g, date)
    .replace(/{domain}/g, domain)
    .replace(/{ext}/g, ext);
}

/**
 * Generate export content based on format
 */
export function generateExportContent(entries: LogEntry[], format: ExportFormat): string {
  switch (format) {
    case 'url-list':
      return generateUrlList(entries);
    case 'bash-curl':
      return generateBashCurl(entries);
    case 'bash-curl-headers':
      return generateBashCurlHeaders(entries);
    case 'bash-yt-dlp':
      return generateBashYtDlp(entries);
    case 'powershell':
      return generatePowerShell(entries);
    default:
      throw new Error(`Unknown export format: ${format}`);
  }
}

/**
 * Export logs to file
 */
export async function exportLogs(
  entries: LogEntry[],
  format: ExportFormat,
  exportSettings: ExportSettings
): Promise<string> {
  if (entries.length === 0) {
    throw new Error('No entries to export');
  }

  // Generate content
  const content = generateExportContent(entries, format);

  // Apply newline settings
  const finalContent = exportSettings.newline === 'CRLF' ? content.replace(/\n/g, '\r\n') : content;

  // Generate filename
  const filename = generateFilename(exportSettings.filenameTemplate, format, entries);

  // Create blob
  const blob = new Blob([finalContent], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);

  // Download file
  const downloadId = await chrome.downloads.download({
    url,
    filename,
    saveAs: true,
  });

  // Clean up blob URL after download
  chrome.downloads.onChanged.addListener(function cleanup(delta) {
    if (delta.id === downloadId && delta.state?.current === 'complete') {
      URL.revokeObjectURL(url);
      chrome.downloads.onChanged.removeListener(cleanup);
    }
  });

  return filename;
}
