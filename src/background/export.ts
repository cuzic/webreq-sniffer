/**
 * Export Module
 * Handles log export to various script formats
 */

import type { LogEntry, LogHeaders, ExportFormat, ExportSettings } from '@/types';
import { ExportError } from '@/lib/errors';
import { EXPORT } from '@/lib/constants';
import { renderTemplate } from '@/lib/template';
import { getBuiltInTemplate } from '@/lib/builtinTemplates';
import { sanitizeFilename } from '@/lib/filename';
import { safeEvaluateTemplate, type TemplateContext } from '@/lib/pipeline-template-engine';
import {
  generateBashBatchDownload,
  generatePowerShellBatchDownload,
} from '@/lib/batch-download-generator';
import { getCookiesForUrl, generateNetscapeCookieJar } from '@/lib/cookie-manager';

/**
 * Check if entries contain manifest with variants
 * Used to determine which export formats are appropriate
 */
export function hasManifestVariants(entries: LogEntry[]): boolean {
  if (entries.length !== 1) {
    return false;
  }

  const variants = entries[0]?.pageMetadata?.manifestMetadata?.variants;
  return (variants?.length ?? 0) > 0;
}

/**
 * Check if entry URL is a manifest file
 */
export function isManifestUrl(url: string): boolean {
  const urlLower = url.toLowerCase();
  return urlLower.includes('.m3u8') || urlLower.includes('.mpd');
}

/**
 * Escape string for Bash shell (single quotes)
 */
export function escapeShellArg(str: string): string {
  // In single quotes, only single quote needs escaping
  // We escape it by ending the quote, adding escaped quote, and starting quote again
  return `'${str.replace(/'/g, "'\\''")}'`;
}

/**
 * Escape string for PowerShell
 */
export function escapePowerShellArg(str: string): string {
  // PowerShell uses backtick for escaping
  return str
    .replace(/`/g, '``')
    .replace(/\$/g, '`$')
    .replace(/"/g, '`"')
    .replace(/\n/g, '`n')
    .replace(/\r/g, '`r');
}

/**
 * Helper: Create bash script header
 */
function createBashHeader(): string[] {
  return ['#!/bin/bash', '# Generated by WebreqSniffer', ''];
}

/**
 * Helper: Format headers for curl/yt-dlp
 */
function formatHeaders(headers: LogHeaders | undefined, format: 'curl' | 'yt-dlp'): string {
  if (!headers || Object.keys(headers).length === 0) return '';

  const parts: string[] = [];
  for (const [key, value] of Object.entries(headers)) {
    const headerValue = escapeShellArg(`${key}: ${value}`);
    if (format === 'curl') {
      parts.push(` -H ${headerValue}`);
    } else {
      parts.push(` --add-header ${headerValue}`);
    }
  }
  return parts.join('');
}

/**
 * Generate plain URL list
 */
export function generateUrlList(entries: LogEntry[]): string {
  return entries.map((entry) => entry.url).join('\n') + '\n';
}

/**
 * Generate Bash curl script (no headers)
 */
export function generateBashCurl(entries: LogEntry[]): string {
  const lines = createBashHeader();

  for (const entry of entries) {
    const url = escapeShellArg(entry.url);
    lines.push(`curl -L ${url}`);
  }

  return lines.join('\n') + '\n';
}

/**
 * Generate Bash curl script with headers
 */
export function generateBashCurlHeaders(entries: LogEntry[]): string {
  const lines = createBashHeader();

  for (const entry of entries) {
    const url = escapeShellArg(entry.url);
    const headers = formatHeaders(entry.headers, 'curl');
    lines.push(`curl -L${headers} ${url}`);
  }

  return lines.join('\n') + '\n';
}

/**
 * Generate Bash yt-dlp script
 */
export function generateBashYtDlp(entries: LogEntry[]): string {
  const lines = createBashHeader();

  for (const entry of entries) {
    const url = escapeShellArg(entry.url);
    let command = 'yt-dlp';

    command += formatHeaders(entry.headers, 'yt-dlp');

    // Add referer if present (yt-dlp specific)
    if (entry.headers?.Referer) {
      const referer = escapeShellArg(entry.headers.Referer);
      command += ` --referer ${referer}`;
    }

    command += ` ${url}`;
    lines.push(command);
  }

  return lines.join('\n') + '\n';
}

/**
 * Generate Bash yt-dlp script with cookies
 * Creates embedded cookie jar in the script
 */
export async function generateBashYtDlpWithCookies(entries: LogEntry[]): Promise<string> {
  const lines = createBashHeader();

  if (entries.length === 0) {
    return lines.join('\n') + '\n';
  }

  // Collect cookies from all unique domains
  const uniqueUrls = [...new Set(entries.map((e) => e.url))];
  const allCookies = await Promise.all(uniqueUrls.map((url) => getCookiesForUrl(url)));
  const flatCookies = allCookies.flat();

  // Generate cookie jar if cookies exist
  if (flatCookies.length > 0) {
    const cookieJar = generateNetscapeCookieJar(flatCookies);

    lines.push('# Create cookie jar file');
    lines.push("cat > cookies.txt << 'COOKIE_JAR'");
    lines.push(cookieJar.trim());
    lines.push('COOKIE_JAR');
    lines.push('');
  }

  // Generate download commands
  for (const entry of entries) {
    const url = escapeShellArg(entry.url);
    let command = 'yt-dlp';

    // Add cookies if available
    if (flatCookies.length > 0) {
      command += ' --cookies cookies.txt';
    }

    command += formatHeaders(entry.headers, 'yt-dlp');

    // Add referer if present (yt-dlp specific)
    if (entry.headers?.Referer) {
      const referer = escapeShellArg(entry.headers.Referer);
      command += ` --referer ${referer}`;
    }

    command += ` ${url}`;
    lines.push(command);
  }

  // Cleanup
  if (flatCookies.length > 0) {
    lines.push('');
    lines.push('# Clean up cookie jar');
    lines.push('rm -f cookies.txt');
  }

  return lines.join('\n') + '\n';
}

/**
 * Generate PowerShell script
 */
export function generatePowerShell(entries: LogEntry[]): string {
  const lines: string[] = [
    '# Generated by WebreqSniffer',
    '$ProgressPreference = "SilentlyContinue"',
    '',
  ];

  for (let i = 0; i < entries.length; i++) {
    const entry = entries[i];
    if (!entry) continue;

    const url = `"${escapePowerShellArg(entry.url)}"`;

    lines.push(`# Request ${i + 1}`);

    if (entry.headers && Object.keys(entry.headers).length > 0) {
      lines.push('$headers = @{');
      for (const [key, value] of Object.entries(entry.headers)) {
        const escapedValue = escapePowerShellArg(value);
        lines.push(`    "${key}" = "${escapedValue}"`);
      }
      lines.push('}');
      lines.push(`Invoke-WebRequest -Uri ${url} -Headers $headers`);
    } else {
      lines.push(`Invoke-WebRequest -Uri ${url}`);
    }

    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Generate filename from pipeline template
 */
export function generateFilename(
  template: string,
  format: ExportFormat,
  entries: LogEntry[]
): string {
  const now = new Date();
  const date = now.toISOString().slice(0, 10); // YYYY-MM-DD
  const time = now.toISOString().slice(11, 19).replace(/:/g, '-'); // HH-mm-ss

  // Extract domain and metadata from first entry
  let domain: string = EXPORT.DEFAULT_DOMAIN;
  const firstEntry = entries.length > 0 ? entries[0] : null;
  const metadata = firstEntry?.pageMetadata;

  if (firstEntry) {
    try {
      const url = new URL(firstEntry.url);
      domain = url.hostname;
    } catch {
      // Invalid URL, use default
    }
  }

  // Determine extension
  const ext = EXPORT.EXTENSIONS[format];

  // Build template context
  const context: TemplateContext = {
    // System variables
    date,
    time,
    timestamp: Date.now(),
    domain,
    ext,

    // Page metadata (with fallbacks)
    pageTitle: metadata?.pageTitle,
    ogTitle: metadata?.ogTitle || metadata?.pageTitle,
    videoTitle: metadata?.videoTitle || metadata?.ogTitle || metadata?.pageTitle,
    metaTitle: metadata?.metaTitle || metadata?.pageTitle,
    metaDescription: metadata?.metaDescription,

    // Manifest metadata
    manifestTitle: metadata?.manifestMetadata?.title,
    manifestType: metadata?.manifestMetadata?.type,
    segmentPattern: metadata?.manifestMetadata?.segmentPattern,
    programDate: metadata?.manifestMetadata?.programDateTime
      ? new Date(metadata.manifestMetadata.programDateTime).toISOString().slice(0, 10)
      : undefined,
  };

  // Evaluate template with pipeline engine
  // Use 'untitled' as fallback if template evaluation fails
  const filename = safeEvaluateTemplate(template, context, `${domain}_${date}.${ext}`);

  // Sanitize filename (removes invalid filesystem characters)
  return sanitizeFilename(filename);
}

/**
 * Generate export content based on format
 * Batch download formats and cookie formats use specialized generators, others use templates
 */
export async function generateExportContent(
  entries: LogEntry[],
  format: ExportFormat
): Promise<string> {
  // Handle batch download formats specially
  if (format === 'bash-batch-download') {
    if (entries.length === 0) {
      throw new ExportError('No entries to export', { format });
    }
    return generateBashBatchDownload(entries[0]);
  }

  if (format === 'powershell-batch-download') {
    if (entries.length === 0) {
      throw new ExportError('No entries to export', { format });
    }
    return generatePowerShellBatchDownload(entries[0]);
  }

  // Handle cookie format (async)
  if (format === 'bash-yt-dlp-cookies') {
    return await generateBashYtDlpWithCookies(entries);
  }

  // All other formats use templates
  const template = getBuiltInTemplate(format);
  if (!template) {
    throw new ExportError(`Template not found for format: ${format}`, { format });
  }
  return renderTemplate(template.template, entries);
}

/**
 * Export logs to file
 */
export async function exportLogs(
  entries: LogEntry[],
  format: ExportFormat,
  exportSettings: ExportSettings
): Promise<string> {
  if (entries.length === 0) {
    throw new ExportError('No entries to export', { entryCount: 0 });
  }

  // Generate content
  const content = await generateExportContent(entries, format);

  // Apply newline settings
  const finalContent = exportSettings.newline === 'CRLF' ? content.replace(/\n/g, '\r\n') : content;

  // Generate filename
  const filename = generateFilename(exportSettings.filenameTemplate, format, entries);

  // Create blob
  const blob = new Blob([finalContent], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);

  // Download file
  const downloadId = await chrome.downloads.download({
    url,
    filename,
    saveAs: true,
  });

  // Clean up blob URL after download
  chrome.downloads.onChanged.addListener(function cleanup(delta) {
    if (delta.id === downloadId && delta.state?.current === 'complete') {
      URL.revokeObjectURL(url);
      chrome.downloads.onChanged.removeListener(cleanup);
    }
  });

  return filename;
}
